[toc]

# 项目初始化

从0开始搭建后端和前端项目，会后续正式开发项目打好基础。
包括：

- 后端项目初始化
- 前端项目初始化

---

## 一、后端初始化

### 环境准备

- Java21+
- MySQL8.x

### 新建项目

在DEA中新建项目，选择Spring Boot模板、Maven、JDK21,配置如图：

![image-20250726145516534](https://picbed-chengfu-1327906653.cos.ap-guangzhou.myqcloud.com/image/image-20250726145516534.webp)

选择Spring Boot3.5.x版本，必须添加的依赖包括Spring Web、.MySQL、Lombok,Spring Boot DevTools可以按需选取：

![image-20250726145613675](https://picbed-chengfu-1327906653.cos.ap-guangzhou.myqcloud.com/image/image-20250726145613675.webp)

当然，后续通过修改Maven配置添加依赖也是可以的。
如果Lombok依赖报错的话，可以手动指定Lombok的版本，修改pom.xml的代码：

```xml
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
  	<version>1.18.36</version>
    <optional>true</optional>
</dependency>
```

点击创建，就得到了一个Spring Boot项目，需要等待Maven为我们安装依赖。
修改资源目录下的配置文件为application.yml,指定项目启动的端口号和访问地址前缀、项目名称，代码如下：

```yml
spring:
  application:
    name: yu-ai-code-mother-api
server:
  port: 8123
  servlet:
    context-path: /api

```

### 整合依赖

接下来我们要整合一些开发项目常用的依赖。

#### Hutool工具库

Hutool是主流的Java工具类库，集合了丰富的工具类，涵盖字符串处理、日期操作、文件处理、加解密、反射、正则匹配等常见功能。它的轻量化和无侵入性让开发者能够专注于业务逻辑而不必编写重复的工具代码。

```xml
<dependency>
    <groupId>cn.hutool</groupId>
    <artifactId>hutool-all</artifactId>
    <version>5.8.38</version>
</dependency>
```

#### Knif4j接口文档

Knif4j是基于Swagger接口文档的增强工具，提供了更加友好的API文档界面和功能扩展，例如动态参数调试、分组文档等。它适合用于Spring Boot项目中，能够通过简单的配置自动生成接口文档，让开发者和前端快速了解和调试接口提高协作效率。

1. 添加依赖

```xml
<dependency>
    <groupId>com.github.xiaoymin</groupId>
    <artifactId>knife4j-openapi3-jakarta-spring-boot-starter</artifactId>
    <version>4.4.0</version>
</dependency>
```

2. 在application.yml中追加接口文档配置，重点是指定扫描Controller包的路径：

```yml
# springdoc-openapi
springdoc:
  group-configs:
    - group: 'default'
      packages-to-scan: com.chengfu.aicodemotherapi.controller
# knife4j
knife4j:
  enable: true
  setting:
    language: zh_cn
```

3. 在controller包中新建一个测试接口

```java
@RestController
@RequestMapping("/health")
public class HealthController {

    @PostMapping("/")
    public BaseResponse<String> healthCheck(){
        return ResultUtils.success("ok");
    }
}
```

重启项目，访问http://localhost:8123/api/doc.html能看到接口文档进行测试。

![image-20250726150440224](https://picbed-chengfu-1327906653.cos.ap-guangzhou.myqcloud.com/image/image-20250726150440224.webp)

#### 其他依赖

可以按需引入其他依赖，比如AOP切面编程：

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-aop</artifactId>
</dependency>
```

给启动类添加注解（可选）:

```java
@EnableAspectJAutoProxy(exposeProxy = true)
```

---

### 通用基础代码

通用基础代码是指：无论在任何后端项目中，都可以复用的代码。这种代码一般”一辈子只用写一次”，了解作用之后复制粘贴即可，无需记忆。

<img src="https://picbed-chengfu-1327906653.cos.ap-guangzhou.myqcloud.com/image/image-20250726150745748.webp" alt="image-20250726150745748" style="zoom:50%;" />

#### 1. 自定义异常

自定义错误码，对错误进行收敛，便于前端统一处理。
这里有2个小技巧：

1. 自定义错误码时，建议跟主流的错误码（比如HTTP错误码）的含义保持一致，比如"未登录”定义为40100,和HTTP401错误（用户需要进行身份认证）保持一致，会更容易理解。
2. 错误码不要完全连续，预留一些间隔，便于后续扩展。

在exception包下新建错误码枚举类：

```java
@Getter
public enum ErrorCode {

    SUCCESS(0, "ok"),
    PARAMS_ERROR(40000, "请求参数错误"),
    NOT_LOGIN_ERROR(40100, "未登录"),
    NO_AUTH_ERROR(40101, "无权限"),
    NOT_FOUND_ERROR(40400, "请求数据不存在"),
    FORBIDDEN_ERROR(40300, "禁止访问"),
    SYSTEM_ERROR(50000, "系统内部异常"),
    OPERATION_ERROR(50001, "操作失败");

    /**
     * 状态码
     */
    private final int code;

    /**
     * 信息
     */
    private final String message;

    ErrorCode(int code, String message) {
        this.code = code;
        this.message = message;
    }

}
```

一般不建议直接抛出Java内置的RuntimeException,而是自定义一个业务异常，和内置的异常类区分开，便于定制化输出错误信息：

```java
@Getter
public class BusinessException extends RuntimeException {

    /**
     * 错误码
     */
    private final int code;

    public BusinessException(int code, String message) {
        super(message);
        this.code = code;
    }

    public BusinessException(ErrorCode errorCode) {
        super(errorCode.getMessage());
        this.code = errorCode.getCode();
    }

    public BusinessException(ErrorCode errorCode, String message) {
        super(message);
        this.code = errorCode.getCode();
    }

}

```

为了更方便地根据情况抛出异常，可以封装一个ThrowUtils,类似断言类，简化抛异常的代码：

```java
public class ThrowUtils {

    /**
     * 条件成立则抛异常
     *
     * @param condition        条件
     * @param runtimeException 异常
     */
    public static void throwIf(boolean condition, RuntimeException runtimeException) {
        if (condition) {
            throw runtimeException;
        }
    }

    /**
     * 条件成立则抛异常
     *
     * @param condition 条件
     * @param errorCode 错误码
     */
    public static void throwIf(boolean condition, ErrorCode errorCode) {
        throwIf(condition, new BusinessException(errorCode));
    }

    /**
     * 条件成立则抛异常
     *
     * @param condition 条件
     * @param errorCode 错误码
     * @param message   错误信息
     */
    public static void throwIf(boolean condition, ErrorCode errorCode, String message) {
        throwIf(condition, new BusinessException(errorCode, message));
    }
}

```

#### 2. 响应包装类

一般情况下，每个后端接口都要返回调用码、数据、调用信息等，前端可以根据这些信息进行相应的处理
我们可以封装统一的响应结果类，便于前端统一获取这些信息。

通用响应类

```java
@Data
public class BaseResponse<T> implements Serializable {

    private int code;

    private T data;

    private String message;

    public BaseResponse(int code, T data, String message) {
        this.code = code;
        this.data = data;
        this.message = message;
    }

    public BaseResponse(int code, T data) {
        this(code, data, "");
    }

    public BaseResponse(ErrorCode errorCode) {
        this(errorCode.getCode(), null, errorCode.getMessage());
    }
}


```

但之后每次接口返回值时，都要手动new一个BaseResponse对象并传入参数，比较麻烦，我们可以新建一个工具类，提供成功调用和失败调用的方法，支持灵活地传参，简化调用。

```java
public class ResultUtils {

    /**
     * 成功
     *
     * @param data 数据
     * @param <T>  数据类型
     * @return 响应
     */
    public static <T> BaseResponse<T> success(T data) {
        return new BaseResponse<>(0, data, "ok");
    }

    /**
     * 失败
     *
     * @param errorCode 错误码
     * @return 响应
     */
    public static BaseResponse<?> error(ErrorCode errorCode) {
        return new BaseResponse<>(errorCode);
    }

    /**
     * 失败
     *
     * @param code    错误码
     * @param message 错误信息
     * @return 响应
     */
    public static BaseResponse<?> error(int code, String message) {
        return new BaseResponse<>(code, null, message);
    }

    /**
     * 失败
     *
     * @param errorCode 错误码
     * @return 响应
     */
    public static BaseResponse<?> error(ErrorCode errorCode, String message) {
        return new BaseResponse<>(errorCode.getCode(), null, message);
    }
}

```

#### 3. 全局异常处理器

为了防止意料之外的异常，利用AOP切面全局对业务异常和RuntimeException进行捕获，首先导入springboot的AOP依赖：

```yml
     	<dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-aop</artifactId>
        </dependency>
```

接下来编写全局异常处理器

```java
@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler {

    @ExceptionHandler(BusinessException.class)
    public BaseResponse<?> businessExceptionHandler(BusinessException e) {
        log.error("BusinessException", e);
        return ResultUtils.error(e.getCode(), e.getMessage());
    }

    @ExceptionHandler(RuntimeException.class)
    public BaseResponse<?> runtimeExceptionHandler(RuntimeException e) {
        log.error("RuntimeException", e);
        return ResultUtils.error(ErrorCode.SYSTEM_ERROR, "系统错误");
    }
}
```

#### 4. 全局跨域配置

跨域是指浏览器访问的URL(前端地址)和后端接口地址的域名（或端口号）不一致导致的，浏览器为了安全，默认禁用跨域请求访问。
为了开发调试方便，我们可以通过全局跨域配置，让整个项目所有的接口支持跨域，解决跨域报错。
新建config包，用于存放所有的配置相关代码。全局跨域配置代码如下：

```java
@Configuration
public class CorsConfig implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        // 覆盖所有请求
        registry.addMapping("/**")
                // 允许发送 Cookie
                .allowCredentials(true)
                // 放行哪些域名（必须用 patterns，否则 * 会和 allowCredentials 冲突）
                .allowedOriginPatterns("*")
                .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")
                .allowedHeaders("*")
                .exposedHeaders("*");
    }
}
```

---

## 二、前端项目初始化

### 环境准备

nodejs版本>=16

查看我的node版本

![image-20250718140920644](https://picbed-chengfu-1327906653.cos.ap-guangzhou.myqcloud.com/image/image-20250718140920644.webp)

### 创建项目

使用Vue官方推荐的脚手架create--vue快速创建Vue3的项目：[快速上手 | Vue.js](https://cn.vuejs.org/guide/quick-start)

Vue提供了在线编码测试，可以通过Playground来学习：https://play.vuejs.org/

在终端输入：

```
npm create vue
```

输入项目名称：

![image-20250718141222220](https://picbed-chengfu-1327906653.cos.ap-guangzhou.myqcloud.com/image/image-20250718141222220.webp)

接下来按照如下选项创建项目，脚手架会自动帮我们安装Vue Router路由、Pinia全局状态管理等实用类库：

![image-20250718141322559](https://picbed-chengfu-1327906653.cos.ap-guangzhou.myqcloud.com/image/image-20250718141322559.webp)

然后用WebStorm打开项目，先在终端执行npm install安装依赖，然后执行npm run dev能访问网页就成功了。

![image-20250718141651997](https://picbed-chengfu-1327906653.cos.ap-guangzhou.myqcloud.com/image/image-20250718141651997.webp)

### 前端工程化配置

脚手架已经帮我们整合了Prettier代码美化、ESLint自动校验、TypeScript类型校验，无需再自行整合。
但是需要在webstorm里开启代码美化插件：

![image-20250718141914067](https://picbed-chengfu-1327906653.cos.ap-guangzhou.myqcloud.com/image/image-20250718141914067.webp)

更改格式化代码快捷键：

![image-20250718141949874](https://picbed-chengfu-1327906653.cos.ap-guangzhou.myqcloud.com/image/image-20250718141949874.webp)

### 引入组件库

引入Ant Design Vue组件库，参考官方文档快速上手。[Components Overview - Ant Design Vue](https://www.antdv.com/components/overview)

代码

```
npm i --save ant-design-vue@4.x
```

改变入口文件main.ts

```typescript
import App from './App.vue'
import router from './router'
import Antd from "ant-design-vue";
import "ant-design-vue/dist/reset.css";

const app = createApp(App)
app.use(Antd);
app.use(createPinia())
app.use(router)

app.mount('#app')
```

### 页面基本信息

可以修改项目根目录下的index.html文件，来定义页面的元信息，比如修改标题：

```html
<!DOCTYPE html>
<html lang="">
  <head>
    <meta charset="UTF-8">
    <link rel="icon" href="/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>智码零界</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.ts"></script>
  </body>
</html>
```

![image-20250726151342164](https://picbed-chengfu-1327906653.cos.ap-guangzhou.myqcloud.com/image/image-20250726151342164.webp)

### 全局通用布局

#### 1. 基础布局结构

在layouts目录下新建-个布局BasicLayout..vue,在App.vue全局页面入口文件中引入。

App.vue

```vue
<template>
  <div id="app">
    <BasicLayout />
  </div>
</template>
<script setup lang="ts">
import BasicLayout from '@/layouts/BasicLayout.vue'
</script>
<style scoped>
#app {
}
</style>
```

BasicLayout.vue

```vue
<template>
  <div id="basicLayout"></div>
</template>
<script setup lang="ts"></script>
<style scoped></style>
```

选用Ant Design组件库的Layout组件，先把【上中下】布局编排好，然后再填充内容：

![image-20250718151256812](https://picbed-chengfu-1327906653.cos.ap-guangzhou.myqcloud.com/image/image-20250718151256812.webp)

BasicLayout.vue

```vue
<template>
  <div id="basicLayout">
    <a-layout style="min-height: 100vh">
      <a-layout-header>Header</a-layout-header>
      <a-layout-content>Content</a-layout-content>
      <a-layout-footer>Footer</a-layout-footer>
    </a-layout>
  </div>
</template>

<script setup lang="ts"></script>
<style scoped>
#basicLayout {
}
</style>
```

#### 2. 全局底部栏

通常用于展示版权信息

```vue
      <a-layout-footer class="footer">
        <a href="https://github.com/chengfushi" target="_blank"> GitHub By Chengfu </a>

        <a href="https://github.com/camellialoveit" target="_blank"> and Yike </a>
      </a-layout-footer>
    </a-layout>
```

样式

```css
#basicLayout .footer {
  background: #efefef;
  padding: 16px;
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  text-align: center;
}
```

#### 3. 动态替换内容

项目使用了VueRouter路由库，可以在router/index.ts配置路由，能够根据访问的页面地址找到不同的文件并加载渲染。
修改BasicLayout内容部分的代码如下：

```vue
      <a-layout-content>
        <router-view class="content" />
      </a-layout-content>
```

样式：

```css
<style scoped>
#basicLayout .content {
  background: linear-gradient(to right, #fefefe, #fff);
  margin-bottom: 28px;
  padding: 20px;
}
</style>
```

#### 4. 全局顶部栏

由于顶部栏的开发相对复杂，可以基于Ant Design的菜单组件来创建GlobalHeader全局顶部栏组件**组件统一放在components 目录中 **。
先直接复制现成的组件示例代码到GlobalHeader中即可。

![image-20250718154040937](https://picbed-chengfu-1327906653.cos.ap-guangzhou.myqcloud.com/image/image-20250718154040937.webp)

引入代码

```vue
<a-layout-header class="header">
  <GlobalHeader />
</a-layout-header>
```

样式：

```css
#basicLayout .header {
  padding-inline: 20px;
  margin-bottom: 16px;
  color: unset;
  background: white;
}
```

效果如下：

![image-20250718154705546](https://picbed-chengfu-1327906653.cos.ap-guangzhou.myqcloud.com/image/image-20250718154705546.webp)

接下来要修改GlobalHeader组件，完善更多内容。
1)给菜单外套一层元素，用于整体控制样式：

```vue
<div id="globalHeader">
  <a-menu v-model:selectedKeys="current" mode="horizontal" :items="items" />
</div>
```

2)根据我们的需求修改菜单配置，key为要跳转的URL路径：

```typescript
import { h, ref } from 'vue'
import { HomeOutlined } from '@ant-design/icons-vue'
import { MenuProps } from 'ant-design-vue'

const current = ref<string[]>(['home'])
const items = ref<MenuProps['items']>([
  {
    key: '/',
    icon: () => h(HomeOutlined),
    label: '主页',
    title: '主页',
  },
  {
    key: 'others',
    label: h('a', { href: 'https://chengfushi.blog.csdn.net/', target: '_blank' }, '个人博客'),
    title: '个人博客',
  },
])
```

![image-20250718155104421](https://picbed-chengfu-1327906653.cos.ap-guangzhou.myqcloud.com/image/image-20250718155104421.webp)

3)完善全局顶部栏，左侧补充网站图标和标题。
先把Iogo.png放到src/assets目录下，替换掉原本的默认Logo:

修改GlobalHeader组件：

```vue
<RouterLink to="/">
  <div class="title-bar">
    <img class="logo" src="../assets/logo.png" alt="logo" />
    <div class="title">智码零界</div>
  </div>
</RouterLink>
```

补充css

```css
<style scoped>
.title-bar {
  display: flex;
  align-items: center;
}

.title {
  color: black;
  font-size: 18px;
  margin-left: 16px;
}

.logo {
  height: 48px;
}
</style>
```

![image-20250726151455395](https://picbed-chengfu-1327906653.cos.ap-guangzhou.myqcloud.com/image/image-20250726151455395.webp)

看着还是巨丑无比

4)完善顶部导航栏，右侧展示当前用户的登录状态（暂时用登录按钮代替）：

```vue
<div class="user-login-status">
  <a-button type="primary" href="/user/login">登录</a-button>
</div>
```

5)优化导航栏的布局，采用栅格组件的自适应布局（左中右结构，左侧右侧宽度固定，中间菜单栏自适应）

```vue
 <a-row :wrap="false">
      <a-col flex="200px">
        <RouterLink to="/">
          <div class="title-bar">
            <img class="logo" src="../assets/logo.png" alt="logo" />
            <div class="title">用户中心</div>
          </div>
        </RouterLink>
      </a-col>
      <a-col flex="auto">
        <a-menu v-model:selectedKeys="current" mode="horizontal" :items="items" />
      </a-col>
      <a-col flex="120px">
        <div class="user-login-status">
          <a-button type="primary" href="/user/login">登录</a-button>
        </div>
      </a-col>
    </a-row>
```

现在导航栏就显得好看了

![](https://picbed-chengfu-1327906653.cos.ap-guangzhou.myqcloud.com/image/image-20250726151455395.webp)

### 路由

目标：点击菜单项后，可以跳转到对应的页面；并且刷新页面后，对应的菜单自动高亮。

#### 1.修改路由配置

创建一个页面HomePage：

<img src="https://picbed-chengfu-1327906653.cos.ap-guangzhou.myqcloud.com/image/image-20250718160225615.webp" alt="image-20250718160225615" style="zoom:50%;" />

代码：

```vue
<template>
  <div id="homePage"></div>
</template>
<script setup lang="ts"></script>
```



按需修改router/index.ts文件的routes配置，定义我们需要的页面路由，每个path对应一个component(要加载的组件)：

```typescript
const router = createRouter({
  history: createWebHistory(import.meta.env.BASE_URL),
  routes: [
    {
      path:'/',
      name:'home',
      component: HomePage
    }
  ],
})
```

#### 2. 路由跳转

给GlobalHeader的菜单组件绑定跳转事件：

```typescript
import { useRouter } from 'vue-router'
const router = useRouter()

// 路由跳转事件
const doMenuClick = ({ key }: { key: string }) => {
  router.push({
    path: key,
  })
}
```

修改菜单栏：

```vue
      <a-col flex="auto">
        <a-menu
          v-model:selectedKeys="current"
          mode="horizontal"
          :items="items"
          @click="doMenuClick"
        />
      </a-col>
```

#### 3. 高亮同步

刷新页面后，你会发现当前菜单项并没有高亮，所以需要同步路由的更新到菜单项高亮。
同步高亮原理：

1. 点击菜单时，Ant Design组件已经通过v-model绑定current变量实现了高亮。
2. 刷新页面时，需要获取到当前URL路径，然后修改current变量的值，从而实现同步。

使用Vue Router的afterEach路由钩子实现，每次改变路由或刷新页面时都会自动更新current的值，从而实现高亮：

```typescript
const router = useRouter();
// 当前选中菜单
const current = ref<string[]>([]);
// 监听路由变化，更新当前选中菜单
router.afterEach((to, from, next) => {
  current.value = [to.path];
});

```



### 请求

一般情况下，前端只负责界面展示和动效交互，尽量避免写复杂的逻辑；当需要获取数据时，通常是向后端提供的接口发送请求，由后端执行操作（比如保存数据）并响应数据给前端。
前端如何向后端发送请求呢？最传统的方式是使用A八X技术。但其代码有些复杂，我们可以使用第三方的封装库，来简化发送请求的代码，比如主流的请求工具库AxoS。

#### 1.请求工具库

安装请求工具类Axios.,参考官方文档：[Getting Started | Axios Docs](https://axios-http.com/docs/intro)

代码

```
npm install axios
```

#### 2. 全局自定义请求

需要自定义全局请求地址等，参考Axios官方文档，编写请求配置文件request.ts。
包括全局接口请求地址、超时时间、自定义请求响应拦截器等。
响应拦截器的应用场景：我们需要对接口的通用响应进行统一处理，比如从response中取出data;或者根据code去集中处理错误。这样不用在每个接口请求中都去写相同的逻辑。
比如可以在全局响应拦截器中，读取出结果中的data,并校验code是否合法，如果是未登录状态，则自动登录。
示例代码如下，其中withCredentials:true一定要写，否则无法在发请求时携带Cookie,就无法完成登录。

```typescript
import axios from 'axios'
import { message } from 'ant-design-vue'

// 创建 Axios 实例
const myAxios = axios.create({
  baseURL: 'http://localhost:8123/api',
  timeout: 60000,
  withCredentials: true,
})

// 全局请求拦截器
myAxios.interceptors.request.use(
  function (config) {
    // Do something before request is sent
    return config
  },
  function (error) {
    // Do something with request error
    return Promise.reject(error)
  },
)

// 全局响应拦截器
myAxios.interceptors.response.use(
  function (response) {
    const { data } = response
    // 未登录
    if (data.code === 40100) {
      // 不是获取用户信息的请求，并且用户目前不是已经在用户登录页面，则跳转到登录页面
      if (
        !response.request.responseURL.includes('user/get/login') &&
        !window.location.pathname.includes('/user/login')
      ) {
        message.warning('请先登录')
        window.location.href = `/user/login?redirect=${window.location.href}`
      }
    }
    return response
  },
  function (error) {
    // Any status codes that falls outside the range of 2xx cause this function to trigger
    // Do something with response error
    return Promise.reject(error)
  },
)

export default myAxios
```



#### 自动生成请求代码

如果采用传统开发方式，针对每个请求都要单独编写代码，很麻烦。
推荐使用OpenAPI工具，直接自动生成即可：[@umijs/openapi - npm](https://www.npmjs.com/package/@umijs/openapi)
按照官方文档的步骤，先安装：

```
npm i --save-dev @umijs/openapi
```

在**项目根目录**新建openapi.config.js,根据自己的需要定制生成的代码：

```javascript
import { generateService } from '@umijs/openapi'

generateService({
  requestLibPath: "import request from '@/request'",
  schemaPath: 'http://localhost:8123/api/v3/api-docs',
  serversPath: './src',
})
```

控制台输入：

```javascript
node openapi.config.js
```

![image-20250718142724920](https://picbed-chengfu-1327906653.cos.ap-guangzhou.myqcloud.com/image/image-20250718142724920.webp)

成功生成接口函数

![image-20250718142810067](https://picbed-chengfu-1327906653.cos.ap-guangzhou.myqcloud.com/image/image-20250718142810067.webp)

这里我们测试一下，找到app.vue界面,输入一下代码：

```javascript
import { health } from "@/api/mainController.ts";

health().then(res =>{
  console.log(res);
})
```

![image-20250718144329605](https://picbed-chengfu-1327906653.cos.ap-guangzhou.myqcloud.com/image/image-20250718144329605.webp)

成功，前后端能正常交互。

### 全局状态管理

什么是全局状态管理？
答：所有页面全局共享的变量，而不是局限在某一个页面中。

适合作为全局状态的数据：已登录用户信息（每个页面几乎都要用）
Pinia是一个主流的状态管理库，相比于Vuex来说使用更简单，可参考入门文档进行引入。

#### 1.引入Pinia

此处由于create-vue脚手架已经帮我们整合了Pinia,无需手动引入，直接使用即可。

#### 2.定义状态

在src/stores目录下定义user模块，定义了用户的存储、远程获取、修改逻辑：

<img src="https://picbed-chengfu-1327906653.cos.ap-guangzhou.myqcloud.com/image/image-20250718160950922.webp" alt="image-20250718160950922" style="zoom:50%;" />

```typescript
import { defineStore } from "pinia";
import { ref } from "vue";

export const useLoginUserStore = defineStore("loginUser", () => {
  const loginUser = ref<any>({
    userName: "未登录",
  });

  async function fetchLoginUser() {
    // todo 由于后端还没提供接口，暂时注释
    // const res = await getCurrentUser();
    // if (res.data.code === 0 && res.data.data) {
    //   loginUser.value = res.data.data;
    // }
  }

  function setLoginUser(newLoginUser: any) {
    loginUser.value = newLoginUser;
  }

  return { loginUser, setLoginUser, fetchLoginUser };
});
```

#### 3.使用状态

可以直接使用store中导出的状态变量和函数。
在首次进入到页面时，一般我们会尝试获取登录用户信息。修改App.vue,编写远程获取数据代码：

```typescript
import { useLoginUserStore } from "@/stores/user.ts";
const loginUserStore = useLoginUserStore()
loginUserStore.fetchLoginUser()
```

在任何页面中都可以使用数据，比如GlobalHeader全局顶部栏组件中直接展示：

修改全局顶部栏组件，在右侧展示登录状态：

```vue
<div class="user-login-status">
  <div v-if="loginUserStore.loginUser.id">
    {{ loginUserStore.loginUser.userName ?? '无名' }}
  </div>
  <div v-else>
    <a-button type="primary" href="/user/login">登录</a-button>
  </div>
</div>

```

#### 4. 模拟登录

在user.ts中编写逻辑，模拟3秒后登录：

```typescript
async function fetchLoginUser() {
  // 测试用户登录，3 秒后登录
  setTimeout(() => {
    loginUser.value = { userName: '测试用户', id: 1 }
  }, 3000)
}

```

---

至此，前端项目初始化完成

[toc]

# 用户模块

## 需求分析

对于用户模块，通常要具有下列功能：

* 用户注册
* 用户登录
* 获取当前登录用户
* 用户注销
* 用户权限控制
* 【管理员】管理用户

具体分析每个需求：

1. 用户注册：用户可以通过输入账号、密码、确认密码进行注册
2. 用户登录：用户可以通过输入账号和密码登录
3. 获取当前的登录用户：得到当前已经登录的用户信息（不用重复登录）
4. 用户注销：用户可以退出登录
5. 用户权限控制：用户又分为普通用户和管理员，管理员拥有整个系统的最高权限，比如可以管理其他用户
6. 用户管理：仅管理员可用，可以对整个系统中的用户进行管理，比如搜索用户、删除用户

## 方案设计

实现用户模块的难度不大，方案设计阶段我们需要确认：

* 库表设计
* 用户登录流程
* 如何对用户权限进行控制？

## 库表设计

### 核心设计

```sql
-- 用户表
create table if not exists user
(
    id           bigint auto_increment comment 'id' primary key,
    userAccount  varchar(256)                        not null comment '账号',
    userPassword varchar(512)                        not null comment '密码',
    userName     varchar(256)                        null comment '用户昵称',
    userAvatar   varchar(1024)                       null comment '用户头像',
    userProfile  varchar(512)                        null comment '用户简介',
    userRole     varchar(256) default 'user'         not null comment '用户角色：user/admin',
    editTime     datetime     default CURRENT_TIMESTAMP not null comment '编辑时间',
    createTime   datetime     default CURRENT_TIMESTAMP not null comment '创建时间',
    updateTime   datetime     default CURRENT_TIMESTAMP not null on update CURRENT_TIMESTAMP comment '更新时间',
    isDelete     tinyint      default 0               not null comment '是否删除',
    UNIQUE KEY uk_userAccount (userAccount),
    INDEX idx_userName (userName)
) comment '用户' collate = utf8mb4_unicode_ci;
```

几个注意事项：

1. editTime 和 updateTime 的区别：editTime 表示用户编辑个人信息的时间（需要业务代码来更新），而 updateTime 表示这条记录任何字段发生修改的时间（由数据库自动更新）。
2. 给唯一值添加唯一键（唯一索引），比如账号 userAccount，利用数据库天然防重复，同时可以增加查询效率。
3. 给经常用于查询的字段添加索引，比如用户昵称 userName，可以增加查询效率。

建议养成好习惯，将库表设计 SQL 保存到项目的目录中，比如新建 sql/create_table.sql 文件，这样其他开发者就能更快地了解项目。

<img src="https://picbed-chengfu-1327906653.cos.ap-guangzhou.myqcloud.com/image/image-20250728202015139.webp" alt="image-20250728202015139" style="zoom:50%;" />

### 扩展设计

1）如果要实现会员功能，可以对表进行如下扩展：

1. 给 userRole 字段新增枚举值 vip，表示会员用户，可根据该值判断用户权限
2. 新增会员过期时间字段，可用于记录会员有效期
3. 新增会员兑换码字段，可用于记录会员的开通方式
4. 新增会员编号字段，可用于定位用户并提供额外服务，并增加会员归属感

对应的 SQL 如下：




```SQL
vipExpireTime datetime         null comment '会员过期时间',
vipCode       varchar(128)     null comment '会员兑换码',
vipNumber      bigint           null comment '会员编号'
```



2）如果要实现用户邀请功能，可以对表进行如下扩展：

1. 新增 shareCode 分享码字段，用于记录每个用户的唯一邀请标识，可拼接到邀请网址后面，比如 https://mianshiyuan/shareCode=xxx
2. 新增 inviteUser 字段，用于记录该用户被哪个用户邀请了，可通过这个字段查询某用户邀请的用户列表。

对应的 SQL 如下：


```SQL
shareCode     varchar(28) DEFAULT NULL COMMENT '分享码',
inviteUser     bigint          DEFAULT NULL COMMENT '邀请用户 id'
```



## 用户登录流程

1）建立初始会话：前端与服务器建立连接后，服务器会为该客户端创建一个初始的匿名 Session，并将其状态保存下来。这个 Session 的 ID 会作为唯一标识，返回给前端。

2）登录成功，更新会话信息：当用户在前端输入正确的账号密码并提交到后端验证成功后，后端会更新该用户的 Session，将用户的登录信息（如用户 ID、用户名等）保存到与该 Session 关联的存储中。同时，服务器会生成一个 Set-Cookie 的响应头，指示前端保存该用户的 Session ID。

3）前端保存 Cookie：前端接收到后端的响应后，浏览器会自动根据 Set-Cookie 指令，将 Session ID 存储到浏览器的 Cookie 中，与该域名绑定。

4）带 Cookie 的后续请求：当前端再次向相同域名的服务器发送请求时，浏览器会自动在请求头中附带之前保存的 Cookie，其中包含 Session ID。

5）后端验证会话：服务器接收到请求后，从请求头中提取 Session ID，找到对应的 Session 数据。

6）获取会话中存储的信息：后端通过该 Session 获取之前存储的用户信息（如登录名、权限等），从而识别用户身份并执行相应的业务逻辑。

<img src="https://picbed-chengfu-1327906653.cos.ap-guangzhou.myqcloud.com/image/image-20250729134851976.webp" alt="image-20250729134851976" style="zoom:50%;" />



## 如何对用户权限进行控制？

可以将接口分为 4 种权限：

1. 未登录也可以使用
2. 登录用户才能使用
3. 未登录也可以使用，但是登录用户能进行更多操作（比如登录后查看全文）
4. 仅管理员才能使用

传统的权限控制方法是，在每个接口内单独编写逻辑：先获取到当前登录用户信息，然后判断用户的权限是否符合要求。这种方法最灵活，但是会写很多重复的代码，而且其他开发者无法一眼得知接口所需要的权限。

权限校验其实是一个比较通用的业务需求，一般会通过 **Spring AOP 切面 + 自定义权限校验注解 **实现统一的接口拦截和权限校验；如果有特殊的权限校验逻辑，再单独在接口中编码。

👇 如果需要更复杂更灵活的权限控制，可以引入 Shiro / Spring Security / Sa-Token 等专门的权限管理框架

返回处理结果（如页面或数据）

## 后端开发

### MyBatis-Flex代码生成器

#### 1.什么是MyBatis-Flex？

这次我们来学一个新的数据访问层框架MyBatis Flex,它的作用和MyBatis Plus一样，都是对传统操作数据库的MyBatis框架进行增强。它的3大优势：

- 更轻量：MyBatis-Flex除了MyBatis本身，再无任何第三方依赖，因此会带来更高的自主性、把控性和稳定性。在任何一个系统中，依赖越多，稳定性越差。
- 更灵活：小yBatis-Flex提供了非常灵活的QueryWrapper,:支持关联查询、多表查询、多主键、逻辑删除、乐观锁更新、数据填充、数据脱敏等等。
- 更高的性能：MyBatis-FIex通过独特的架构，没有任何小yBatis拦截器、在SQL执行的过程中，没有任何的SQL Parse,因此会带来指数级的性能增长。

官方文档中提到了和MyBatis Plus的功能对比，我认为比较有竞争力的是它支持**多表查询**：

![image-20250729135300375](https://picbed-chengfu-1327906653.cos.ap-guangzhou.myqcloud.com/image/image-20250729135300375.webp)

此外，在ybatis Flex中，有了一个名称为`mybatis-flex-codegen`的模块，提供了可以通过数据库表，生成代码的功能。当我们把数据库表设计完成后，就可以使用其快速生成Entity、Mapper、Service、.Controller代码，能大幅提高我们的开发效率。

#### 2. 使用代码生成器

1. 引入Mybatis-Flex依赖，注意版本：

```xml
<dependency>
    <groupId>com.mybatis-flex</groupId>
    <artifactId>mybatis-flex-spring-boot3-starter</artifactId>
    <version>1.11.0</version>
</dependency>
```

还需要生成器相关依赖：

```xml
<!-- 代码生成模块 -->
<dependency>
    <groupId>com.mybatis-flex</groupId>
    <artifactId>mybatis-flex-codegen</artifactId>
    <version>1.11.0</version>
</dependency>
<!-- 数据库连接池 -->
<dependency>
    <groupId>com.zaxxer</groupId>
    <artifactId>HikariCP</artifactId>
</dependency>
```

2. 数据库相关配置

```yml
spring:
  application:
    name: ai-code-mother-api
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: xxx
    username: xxx
    password: xxx
```

3. 开发生成器：

在根包下新建generator包，新建小MyBatisCodeGenerator类，编写代码生成器。先从官方复制示例代码，然后按需修改即可。
在Mybatis Flex的代码生成器中，支持8种类型的的产物生成，我们只需要关注前6个就好：

- Entity实体类☑
- Mapper映射类☑
- Service服务类☑
- Servicelmpl服务实现类☑
- Controller控制类☑
- MapperXml文件☑
- TableDef表定义辅助类
- info iava文件

```Java
/**
 * @Author: Chengfu Shi
 * @Description: 代码生成器
 **/
public class MyBatisCodeGenerator {

    public static final String[] DATABASE_NAMES = {"user"};

    public static void main(String[] args) {

        Dict dict = YamlUtil.loadByPath("application-local.yml");
        Map<String,Object> datasourceConfig = dict.getByPath("spring.datasource");
        String url = String.valueOf(datasourceConfig.get("url"));
        String username = String.valueOf(datasourceConfig.get("username"));
        String password = String.valueOf(datasourceConfig.get("password"));

        //配置数据源
        HikariDataSource dataSource = new HikariDataSource();
        dataSource.setJdbcUrl(url);
        dataSource.setUsername(username);
        dataSource.setPassword(password);

        GlobalConfig globalConfig = createGlobalConfig();

        //通过 datasource 和 globalConfig 创建代码生成器
        Generator generator = new Generator(dataSource, globalConfig);

        //生成代码
        generator.generate();
    }


    public static GlobalConfig createGlobalConfig() {
        //创建配置内容
        GlobalConfig globalConfig = new GlobalConfig();

        //设置根包
        globalConfig.getPackageConfig()
                .setBasePackage("com.chengfu.aicodemotherapi.genresult");

        //设置表前缀和只生成哪些表，setGenerateTable 未配置时，生成所有表
        globalConfig.getStrategyConfig()
                .setGenerateTable(DATABASE_NAMES)
                //设置逻辑删除字段
                        .setLogicDeleteColumn("isDelete");

        //设置生成 entity 并启用 Lombok
        globalConfig.enableEntity()
                .setWithLombok(true)
                .setJdkVersion(21);

        //设置生成 mapper
        globalConfig.enableMapper();
        globalConfig.enableMapperXml();

        // 设置生成 service
        globalConfig.enableService();
        globalConfig.enableServiceImpl();

        // 设置生成 controller
        globalConfig.enableController();

        // 设置生成时间和字符串为空，避免多余的代码改动
        globalConfig.getJavadocConfig()
                .setAuthor("Chengfu")
                .setSince("");

        return globalConfig;
    }
}

```

上述代码中，我们从配置文件中获取数据库连接信息，用来初始化数据源。然后自定义了一些生成配置，包括：

- 指定逻辑删除字段
- 使用的DK版本
- 生成的代码放到哪个包（建议选择一个独立的包，不要跟老代码混一起）
- 要生成哪些文件

4. 设置mapper扫描路径：

```java
@SpringBootApplication
@EnableAspectJAutoProxy(exposeProxy = true)
@MapperScan("com.chengfu.aicodemotherapi.mapper")
public class AiCodeMotherApiApplication {

    public static void main(String[] args) {
        SpringApplication.run(AiCodeMotherApiApplication.class, args);
    }

}
```

启动项目，正常运行：

![image-20250729141344650](https://picbed-chengfu-1327906653.cos.ap-guangzhou.myqcloud.com/image/image-20250729141344650.webp)

### 数据模型开发

#### 1.实体类

生成的代码也许不能完全满足我们的要求，比如数据库实体类，我们可以手动更改其字段配置，指定主键生成策略。id默认是连续生成的，容易被爬虫抓取，所以更换策略为ASSIGN ID雪花算法生成。
修改User类的代码如下：

```java
@Table("user")
public class User implements Serializable {

    @Id(keyType = KeyType.Generator, value = KeyGenerators.snowFlakeId)
    private Long id;
}

```

#### 2.枚举类

对于用户角色这样值的数量有限的、可枚举的字段，最好定义一个枚举类，便于在项目中获取值、减少枚举值输入错误的情况。
在`model.enums`包下新建UserRoleEnum:

```java
@Getter
public enum UserRoleEnum {

    USER("用户", "user"),
    ADMIN("管理员", "admin");

    private final String text;

    private final String value;

    UserRoleEnum(String text, String value) {
        this.text = text;
        this.value = value;
    }

    /**
     * 根据 value 获取枚举
     *
     * @param value 枚举值的value
     * @return 枚举值
     */
    public static UserRoleEnum getEnumByValue(String value) {
        if (ObjUtil.isEmpty(value)) {
            return null;
        }
        for (UserRoleEnum anEnum : UserRoleEnum.values()) {
            if (anEnum.value.equals(value)) {
                return anEnum;
            }
        }
        return null;
    }
}

```

---

下面进行各接口开发

### 用户注册

#### 1.数据模型

在`model.dto.user`下新建用于接受请求参数的类：

```java
@Data
public class UserRegisterRequest implements Serializable {

    private static final long serialVersionUID = 3191241716373120793L;

    /**
     * 账号
     */
    private String userAccount;

    /**
     * 密码
     */
    private String userPassword;

    /**
     * 确认密码
     */
    private String checkPassword;
}
```

#### 2.服务开发

在接口中定义方法：

```java
/**
 * 用户注册
 *
 * @param userAccount   用户账户
 * @param userPassword  用户密码
 * @param checkPassword 校验密码
 * @return 新用户 id
 */
long userRegister(String userAccount, String userPassword, String checkPassword);

```

实现类：

```java
@Override
public long userRegister(String userAccount, String userPassword, String checkPassword) {
    // 1. 校验
    if (StrUtil.hasBlank(userAccount, userPassword, checkPassword)) {
        throw new BusinessException(ErrorCode.PARAMS_ERROR, "参数为空");
    }
    if (userAccount.length() < 4) {
        throw new BusinessException(ErrorCode.PARAMS_ERROR, "用户账号过短");
    }
    if (userPassword.length() < 8 || checkPassword.length() < 8) {
        throw new BusinessException(ErrorCode.PARAMS_ERROR, "用户密码过短");
    }
    if (!userPassword.equals(checkPassword)) {
        throw new BusinessException(ErrorCode.PARAMS_ERROR, "两次输入的密码不一致");
    }
    // 2. 检查是否重复
    QueryWrapper queryWrapper = new QueryWrapper();
    queryWrapper.eq("userAccount", userAccount);
    long count = this.mapper.selectCountByQuery(queryWrapper);
    if (count > 0) {
        throw new BusinessException(ErrorCode.PARAMS_ERROR, "账号重复");
    }
    // 3. 加密
    String encryptPassword = getEncryptPassword(userPassword);
    // 4. 插入数据
    User user = new User();
    user.setUserAccount(userAccount);
    user.setUserPassword(encryptPassword);
    user.setUserName("无名");
    user.setUserRole(UserRoleEnum.USER.getValue());
    boolean saveResult = this.save(user);
    if (!saveResult) {
        throw new BusinessException(ErrorCode.SYSTEM_ERROR, "注册失败，数据库错误");
    }
    return user.getId();
}
```

加密函数：

```java
@Override
public String getEncryptPassword(String userPassword) {
    // 盐值，混淆密码
    final String SALT = "chengfu";
    return DigestUtils.md5DigestAsHex((SALT + userPassword).getBytes());
}
```

#### 3. 接口开发

```java
@RestController
@RequestMapping("/user")
public class UserController {

    @Resource
    private UserService userService;

    /**
     * 用户注册
     *
     * @param userRegisterRequest 用户注册请求
     * @return 注册结果
     */
    @PostMapping("register")
    public BaseResponse<Long> userRegister(@RequestBody UserRegisterRequest userRegisterRequest) {
        ThrowUtils.throwIf(userRegisterRequest == null, ErrorCode.PARAMS_ERROR);
        String userAccount = userRegisterRequest.getUserAccount();
        String userPassword = userRegisterRequest.getUserPassword();
        String checkPassword = userRegisterRequest.getCheckPassword();
        long result = userService.userRegister(userAccount, userPassword, checkPassword);
        return ResultUtils.success(result);
    }
}
```

#### 4. 测试

![image-20250729143324987](https://picbed-chengfu-1327906653.cos.ap-guangzhou.myqcloud.com/image/image-20250729143324987.webp)

### 用户登录

#### 1. 数据模型

在`model.dto.user`包下新建登录请求

```java
@Data
public class UserLoginRequest implements Serializable {

    private static final long serialVersionUID = 3191241716373120793L;

    /**
     * 账号
     */
    private String userAccount;

    /**
     * 密码
     */
    private String userPassword;
}
```

#### 2. 数据脱敏

无论是用户注册还是用户登录接口，都应该返回已登录的用户信息，而且一定要对返回结果进行脱敏处理，不能直接将数据库查到的所有信息都返回给了前端（包括密码）。
在`model.vo`包下新建`LoginuserVo`类，表示脱敏后的登录用户信息：

```java
@Data
public class LoginUserVO implements Serializable {

    /**
     * 用户 id
     */
    private Long id;

    /**
     * 账号
     */
    private String userAccount;

    /**
     * 用户昵称
     */
    private String userName;

    /**
     * 用户头像
     */
    private String userAvatar;

    /**
     * 用户简介
     */
    private String userProfile;

    /**
     * 用户角色：user/admin
     */
    private String userRole;

    /**
     * 创建时间
     */
    private LocalDateTime createTime;

    /**
     * 更新时间
     */
    private LocalDateTime updateTime;

    private static final long serialVersionUID = 1L;
}

```

在UserService中新增获取脱敏后的已登录用户信息方法：

```java
/**
 * 获取脱敏的已登录用户信息
 *
 * @return
 */
LoginUserVO getLoginUserVO(User user);

```

编写方法对应的实现类，其实就是将User类的属性复制到LoginUserVO中，不存在的字段就被过滤掉了.

#### 3.服务开发

在`service`包的UserService中增加方法声明：

```java
/**
 * 用户登录
 *
 * @param userAccount  用户账户
 * @param userPassword 用户密码
 * @param request
 * @return 脱敏后的用户信息
 */
LoginUserVO userLogin(String userAccount, String userPassword, HttpServletRequest request);

```

在UserServicelmpl中增加实现代码，注意多补充一些校验条件，在用户登录成功后，将用户信息存储在当前的Session中。代码加下：

```java
    @Override
    public LoginUserVO userLogin(String userAccount, String userPassword, HttpServletRequest request) {
        // 1. 校验
        if (StrUtil.hasBlank(userAccount, userPassword)) {
            throw new BusinessException(ErrorCode.PARAMS_ERROR, "参数为空");
        }
        if (userAccount.length() < 4) {
            throw new BusinessException(ErrorCode.PARAMS_ERROR, "账号错误");
        }
        if (userPassword.length() < 8) {
            throw new BusinessException(ErrorCode.PARAMS_ERROR, "密码错误");
        }
        // 2. 加密
        String encryptPassword = getEncryptPassword(userPassword);
        // 查询用户是否存在
        QueryWrapper queryWrapper = new QueryWrapper();
        queryWrapper.eq("userAccount", userAccount);
        queryWrapper.eq("userPassword", encryptPassword);
        User user = this.mapper.selectOneByQuery(queryWrapper);
        // 用户不存在
        if (user == null) {
            throw new BusinessException(ErrorCode.PARAMS_ERROR, "用户不存在或密码错误");
        }
        // 3. 记录用户的登录态
        request.getSession().setAttribute(USER_LOGIN_STATE, user);
        // 4. 获得脱敏后的用户信息
        return this.getLoginUserVO(user);
    }
```

注意，由于注册用户时存入数据库的密码是加密后的，查询用户信息时，也要对用户输入的密码进行同样算法的加密，能跟数据库的信息对应上。
可以把上述的Session理解为一个Map,可以给Map设置key和value,每个不同的SessionlD对应的Session存储
不同的，不用担心会污染。所以上述代码中，给Session设置了固定的key(USER LOGIN_STATE),可以将这个key值取为常量，便于后续获取。

在`constant`包下新建UserConstant类，统一声明用户相关的常量：

```java
public interface UserConstant {

    /**
     * 用户登录态键
     */
    String USER_LOGIN_STATE = "user_login";

    //  region 权限

    /**
     * 默认角色
     */
    String DEFAULT_ROLE = "user";

    /**
     * 管理员角色
     */
    String ADMIN_ROLE = "admin";
    
    // endregion
}
```

#### 4. 接口开发

```java
@PostMapping("/login")
public BaseResponse<LoginUserVO> userLogin(@RequestBody UserLoginRequest userLoginRequest, HttpServletRequest request) {
    ThrowUtils.throwIf(userLoginRequest == null, ErrorCode.PARAMS_ERROR);
    String userAccount = userLoginRequest.getUserAccount();
    String userPassword = userLoginRequest.getUserPassword();
    LoginUserVO loginUserVO = userService.userLogin(userAccount, userPassword, request);
    return ResultUtils.success(loginUserVO);
}

```

#### 5. 测试

![image-20250729144414614](https://picbed-chengfu-1327906653.cos.ap-guangzhou.myqcloud.com/image/image-20250729144414614.webp)

### 获取当前登录用户

可以从request请求对象对应的Session中直接获取到之前保存的登录用户信息，无需其他请求参数。

#### 1. 服务开发

```java
/**
 * 获取当前登录用户
 *
 * @param request
 * @return
 */
User getLoginUser(HttpServletRequest request);
```

实现类：

```java
@Override
public User getLoginUser(HttpServletRequest request) {
    // 先判断是否已登录
    Object userObj = request.getSession().getAttribute(USER_LOGIN_STATE);
    User currentUser = (User) userObj;
    if (currentUser == null || currentUser.getId() == null) {
        throw new BusinessException(ErrorCode.NOT_LOGIN_ERROR);
    }
    // 从数据库查询（追求性能的话可以注释，直接返回上述结果）
    long userId = currentUser.getId();
    currentUser = this.getById(userId);
    if (currentUser == null) {
        throw new BusinessException(ErrorCode.NOT_LOGIN_ERROR);
    }
    return currentUser;
}

```

#### 2.接口开发

```java
@GetMapping("/get/login")
public BaseResponse<LoginUserVO> getLoginUser(HttpServletRequest request) {
    User loginUser = userService.getLoginUser(request);
    return ResultUtils.success(userService.getLoginUserVO(loginUser));
}
```

### 用户注销

可以从request请求对象对应的Session中直接获取到之前保存的登录用户信息，来完成注销，无需其他请求参数。

#### 1.服务开发

```java
/**
 * 用户注销
 *
 * @param request
 * @return
 */
boolean userLogout(HttpServletRequest request);
```

实现类

```java
@Override
public boolean userLogout(HttpServletRequest request) {
    // 先判断是否已登录
    Object userObj = request.getSession().getAttribute(USER_LOGIN_STATE);
    if (userObj == null) {
        throw new BusinessException(ErrorCode.OPERATION_ERROR, "未登录");
    }
    // 移除登录态
    request.getSession().removeAttribute(USER_LOGIN_STATE);
    return true;
}
```

#### 2.接口开发

```java
@PostMapping("/logout")
public BaseResponse<Boolean> userLogout(HttpServletRequest request) {
    ThrowUtils.throwIf(request == null, ErrorCode.PARAMS_ERROR);
    boolean result = userService.userLogout(request);
    return ResultUtils.success(result);
}
```

### 用户修改个人信息

#### 1.数据模型

```java
@Data
public class UserEditRequest implements Serializable {
    private static final long serialVersionUID = 1L;
    private Long id;
    private String userName;

    private String userAvatar;

    private String userProfile;

}
```

#### 2.服务开发

```java
    /**
     * 编辑用户
     *
     * @param userEditRequest
     * @param request
     * @return
     */
    boolean userEdit(UserEditRequest userEditRequest, HttpServletRequest request);
```

实现类

```java
@Override
    public boolean userEdit(UserEditRequest userEditRequest, HttpServletRequest request) {
        // 1. 参数校验
        if (userEditRequest == null || userEditRequest.getId() == null) {
            throw new BusinessException(ErrorCode.PARAMS_ERROR, "参数为空");
        }

        // 2. 获取当前登录用户
        User loginUser = getLoginUser(request);
        Long loginUserId = loginUser.getId();
        Long targetUserId = userEditRequest.getId();

        // 3. 验证权限（只能编辑自己的信息，除非是管理员）
        if (!loginUserId.equals(targetUserId) && !UserRoleEnum.ADMIN.getValue().equals(loginUser.getUserRole())) {
            throw new BusinessException(ErrorCode.NO_AUTH_ERROR, "无权限编辑该用户");
        }

        // 4. 构造更新对象
        User updateUser = new User();
        updateUser.setId(targetUserId);

        // 5. 只设置非空字段
        if (StrUtil.isNotBlank(userEditRequest.getUserName())) {
            updateUser.setUserName(userEditRequest.getUserName());
        }
        if (StrUtil.isNotBlank(userEditRequest.getUserAvatar())) {
            updateUser.setUserAvatar(userEditRequest.getUserAvatar());
        }
        if (StrUtil.isNotBlank(userEditRequest.getUserProfile())) {
            updateUser.setUserProfile(userEditRequest.getUserProfile());
        }

        // 6. 执行更新
        boolean updateResult = this.updateById(updateUser);
        if (!updateResult) {
            throw new BusinessException(ErrorCode.SYSTEM_ERROR, "更新失败");
        }

        return true;
    }

```

#### 3. 接口开发

```java
    @PutMapping("/edit")
    public BaseResponse<Boolean> userEdit(@RequestBody UserEditRequest userEditRequest, HttpServletRequest request) {
        ThrowUtils.throwIf(userEditRequest == null, ErrorCode.PARAMS_ERROR);
        boolean result = userService.userEdit(userEditRequest, request);
        ThrowUtils.throwIf(!result, ErrorCode.OPERATION_ERROR,"编辑失败");
        return ResultUtils.success(result);
    }
```

#### 4. 测试

![image-20250729150353965](https://picbed-chengfu-1327906653.cos.ap-guangzhou.myqcloud.com/image/image-20250729150353965.webp)

### 用户权限控制

权限校验其实是一个比较通用的业务需求，一般会通过**Spring AOP切面+自定义权限校验注解**实现统一的接口拦截和权限校验。如果有特殊的权限校验逻辑，再单独在接口中编码。

#### 1. 权限校验注解

首先编写权限校验注解，放到`annotation`包下：

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface AuthCheck {

    /**
     * 必须有某个角色
     */
    String mustRole() default "";
}

```

#### 2. 权限校验切面
编写权限校验AOP,采用环绕通知，在打上该注解的方法执行前后进行一些额外的操作，比如校验权限。
代码如下，放到aop包下：

```java
@Aspect
@Component
public class AuthInterceptor {

    @Resource
    private UserService userService;

    /**
     * 执行拦截
     *
     * @param joinPoint 切入点
     * @param authCheck 权限校验注解
     */
    @Around("@annotation(authCheck)")
    public Object doInterceptor(ProceedingJoinPoint joinPoint, AuthCheck authCheck) throws Throwable {
        String mustRole = authCheck.mustRole();
        RequestAttributes requestAttributes = RequestContextHolder.currentRequestAttributes();
        HttpServletRequest request = ((ServletRequestAttributes) requestAttributes).getRequest();
        // 当前登录用户
        User loginUser = userService.getLoginUser(request);
        UserRoleEnum mustRoleEnum = UserRoleEnum.getEnumByValue(mustRole);
        // 不需要权限，放行
        if (mustRoleEnum == null) {
            return joinPoint.proceed();
        }
        // 以下为：必须有该权限才通过
        // 获取当前用户具有的权限
        UserRoleEnum userRoleEnum = UserRoleEnum.getEnumByValue(loginUser.getUserRole());
        // 没有权限，拒绝
        if (userRoleEnum == null) {
            throw new BusinessException(ErrorCode.NO_AUTH_ERROR);
        }
        // 要求必须有管理员权限，但用户没有管理员权限，拒绝
        if (UserRoleEnum.ADMIN.equals(mustRoleEnum) && !UserRoleEnum.ADMIN.equals(userRoleEnum)) {
            throw new BusinessException(ErrorCode.NO_AUTH_ERROR);
        }
        // 通过权限校验，放行
        return joinPoint.proceed();
    }
}
```

#### 3.使用注解
只要给方法添加了@AuthCheck注解，就必须要登录，否则会抛出异常。
可以设置mustRole为管理员，这样仅管理员才能使用该接口：
```java
@AuthCheck(mustRole Userconstant.ADMIN ROLE)
```

对于不需要登录就能使用的接口，不需要使用该注解。

### 用户管理

用户管理需求具体可以拆分为：
【管理员】创建用户
【管理员】根据id删除用户
【管理员】更新用户
【管理员】分页获取用户列表（需要脱敏）
【管理员】根据id获取用户（未脱敏）
根据id获取用户（脱敏）

#### 1. 数据模型

1. 每个操作都需要提供一个请求类，都放在`dto.user`包下。

用户创建请求

```java
@Data
public class UserAddRequest implements Serializable {

    /**
     * 用户昵称
     */
    private String userName;

    /**
     * 账号
     */
    private String userAccount;

    /**
     * 用户头像
     */
    private String userAvatar;

    /**
     * 用户简介
     */
    private String userProfile;

    /**
     * 用户角色: user, admin
     */
    private String userRole;

    private static final long serialVersionUID = 1L;
}

```

用户更新请求

```java
@Data
public class UserUpdateRequest implements Serializable {

    /**
     * id
     */
    private Long id;

    /**
     * 用户昵称
     */
    private String userName;

    /**
     * 用户头像
     */
    private String userAvatar;

    /**
     * 简介
     */
    private String userProfile;

    /**
     * 用户角色：user/admin
     */
    private String userRole;

    private static final long serialVersionUID = 1L;
}

```

用户查询请求

```java
@EqualsAndHashCode(callSuper = true)
@Data
public class UserQueryRequest extends PageRequest implements Serializable {

    /**
     * id
     */
    private Long id;

    /**
     * 用户昵称
     */
    private String userName;

    /**
     * 账号
     */
    private String userAccount;

    /**
     * 简介
     */
    private String userProfile;

    /**
     * 用户角色：user/admin/ban
     */
    private String userRole;

    private static final long serialVersionUID = 1L;
}

```

2. 由于要提供获取用户信息的接口，需要和获取当前登录用户接口一样对用户信息进行脱敏
   在`model.vo`包下新建UserVO,表示脱敏后的用户：

```java
@Data
public class UserVO implements Serializable {

    /**
     * id
     */
    private Long id;
    
    /**
     * 账号
     */
    private String userAccount;

    /**
     * 用户昵称
     */
    private String userName;

    /**
     * 用户头像
     */
    private String userAvatar;

    /**
     * 用户简介
     */
    private String userProfile;

    /**
     * 用户角色：user/admin
     */
    private String userRole;

    /**
     * 创建时间
     */
    private LocalDateTime createTime;

    private static final long serialVersionUID = 1L;
}
```

#### 2. 服务开发

1. 在UserService中编写获取脱敏后的单个用户信息、获取脱敏后的用户列表方法：

```java
@Override
public UserVO getUserVO(User user) {
    if (user == null) {
        return null;
    }
    UserVO userVO = new UserVO();
    BeanUtil.copyProperties(user, userVO);
    return userVO;
}

@Override
public List<UserVO> getUserVOList(List<User> userList) {
    if (CollUtil.isEmpty(userList)) {
        return new ArrayList<>();
    }
    return userList.stream().map(this::getUserVO).collect(Collectors.toList());
}
```

2. 除了上述方法外，对于分页查询接口，需要根据用户传入的参数来构造SQL查询。由于使用lyBatis Flex框架，不用自己拼接SQL了，而是通过构造QueryWrapper对象来生成SQL查询。

可以在UserService中编写一个方法，专门用于将查询请求转为QueryWrapper对象：
```java
@Override
public QueryWrapper getQueryWrapper(UserQueryRequest userQueryRequest) {
    if (userQueryRequest == null) {
        throw new BusinessException(ErrorCode.PARAMS_ERROR, "请求参数为空");
    }
    Long id = userQueryRequest.getId();
    String userAccount = userQueryRequest.getUserAccount();
    String userName = userQueryRequest.getUserName();
    String userProfile = userQueryRequest.getUserProfile();
    String userRole = userQueryRequest.getUserRole();
    String sortField = userQueryRequest.getSortField();
    String sortOrder = userQueryRequest.getSortOrder();
    return QueryWrapper.create()
            .eq("id", id)
            .eq("userRole", userRole)
            .like("userAccount", userAccount)
            .like("userName", userName)
            .like("userProfile", userProfile)
            .orderBy(sortField, "ascend".equals(sortOrder));
}

```

#### 3. 接口开发

上述功能其实都是样板代码，俗称“增删改查”。
代码实现比较简单，注意添加对应的权限注解、做好参数校验即可：

```java
/**
 * 创建用户
 */
@PostMapping("/add")
@AuthCheck(mustRole = UserConstant.ADMIN_ROLE)
public BaseResponse<Long> addUser(@RequestBody UserAddRequest userAddRequest) {
    ThrowUtils.throwIf(userAddRequest == null, ErrorCode.PARAMS_ERROR);
    User user = new User();
    BeanUtil.copyProperties(userAddRequest, user);
    // 默认密码 12345678
    final String DEFAULT_PASSWORD = "12345678";
    String encryptPassword = userService.getEncryptPassword(DEFAULT_PASSWORD);
    user.setUserPassword(encryptPassword);
    boolean result = userService.save(user);
    ThrowUtils.throwIf(!result, ErrorCode.OPERATION_ERROR);
    return ResultUtils.success(user.getId());
}

/**
 * 根据 id 获取用户（仅管理员）
 */
@GetMapping("/get")
@AuthCheck(mustRole = UserConstant.ADMIN_ROLE)
public BaseResponse<User> getUserById(long id) {
    ThrowUtils.throwIf(id <= 0, ErrorCode.PARAMS_ERROR);
    User user = userService.getById(id);
    ThrowUtils.throwIf(user == null, ErrorCode.NOT_FOUND_ERROR);
    return ResultUtils.success(user);
}

/**
 * 根据 id 获取包装类
 */
@GetMapping("/get/vo")
public BaseResponse<UserVO> getUserVOById(long id) {
    BaseResponse<User> response = getUserById(id);
    User user = response.getData();
    return ResultUtils.success(userService.getUserVO(user));
}

/**
 * 删除用户
 */
@PostMapping("/delete")
@AuthCheck(mustRole = UserConstant.ADMIN_ROLE)
public BaseResponse<Boolean> deleteUser(@RequestBody DeleteRequest deleteRequest) {
    if (deleteRequest == null || deleteRequest.getId() <= 0) {
        throw new BusinessException(ErrorCode.PARAMS_ERROR);
    }
    boolean b = userService.removeById(deleteRequest.getId());
    return ResultUtils.success(b);
}

/**
 * 更新用户
 */
@PostMapping("/update")
@AuthCheck(mustRole = UserConstant.ADMIN_ROLE)
public BaseResponse<Boolean> updateUser(@RequestBody UserUpdateRequest userUpdateRequest) {
    if (userUpdateRequest == null || userUpdateRequest.getId() == null) {
        throw new BusinessException(ErrorCode.PARAMS_ERROR);
    }
    User user = new User();
    BeanUtil.copyProperties(userUpdateRequest, user);
    boolean result = userService.updateById(user);
    ThrowUtils.throwIf(!result, ErrorCode.OPERATION_ERROR);
    return ResultUtils.success(true);
}

/**
 * 分页获取用户封装列表（仅管理员）
 *
 * @param userQueryRequest 查询请求参数
 */
@PostMapping("/list/page/vo")
@AuthCheck(mustRole = UserConstant.ADMIN_ROLE)
public BaseResponse<Page<UserVO>> listUserVOByPage(@RequestBody UserQueryRequest userQueryRequest) {
    ThrowUtils.throwIf(userQueryRequest == null, ErrorCode.PARAMS_ERROR);
    long pageNum = userQueryRequest.getPageNum();
    long pageSize = userQueryRequest.getPageSize();
    Page<User> userPage = userService.page(Page.of(pageNum, pageSize),
            userService.getQueryWrapper(userQueryRequest));
    // 数据脱敏
    Page<UserVO> userVOPage = new Page<>(pageNum, pageSize, userPage.getTotalRow());
    List<UserVO> userVOList = userService.getUserVOList(userPage.getRecords());
    userVOPage.setRecords(userVOList);
    return ResultUtils.success(userVOPage);
}

```

### 数据精度修复

```java
/**
 * Spring MVC Json 配置
 */
@JsonComponent
public class JsonConfig {

    /**
     * 添加 Long 转 json 精度丢失的配置
     */
    @Bean
    public ObjectMapper jacksonObjectMapper(Jackson2ObjectMapperBuilder builder) {
        ObjectMapper objectMapper = builder.createXmlMapper(false).build();
        SimpleModule module = new SimpleModule();
        module.addSerializer(Long.class, ToStringSerializer.instance);
        module.addSerializer(Long.TYPE, ToStringSerializer.instance);
        objectMapper.registerModule(module);
        return objectMapper;
    }
}
```

## 前端开发

### 新建页面和路由

![image-20250729153743290](https://picbed-chengfu-1327906653.cos.ap-guangzhou.myqcloud.com/image/image-20250729153743290.webp)

修改路由配置：

```ts
routes: [
  {
    path: '/',
    name: '主页',
    component: HomePage,
  },
  {
    path: '/user/login',
    name: '用户登录',
    component: UserLoginPage,
  },
  {
    path: '/user/register',
    name: '用户注册',
    component: UserRegisterPage,
  },
  {
    path: '/admin/userManage',
    name: '用户管理',
    component: UserManagePage,
  },
],

```

记得执行一下openapi工具生成接口对应的请求代码，每次后端改动时都需要这么做。

### 用户登录与注册页面

```vue
<template>
  <div class="center">
    <h1>Sign in/ Sign up</h1>
    <div class="logon">
      <div :class="overlaylong">
        <div class="overlaylong-Signin" v-if="disfiex == 0">
          <h2 class="overlaylongH2">Sign in</h2>
          <a-form
            style="max-width: 700px; margin: 0 auto"
            label-align="left"
            :label-col="{ span: 4 }"
            :wrapper-col="{ span: 20 }"
            :model="form1"
            @finish="handleLogin"
          >
            <a-form-item
              name="userAccount"
              label="账号"
              :rules="[
                { required: true, message: '请输入账号' },
                { min: 4, message: '账号不少于 4 位' },
                { max: 20, message: '账号不超过 20 位' },
              ]"
            >
              <a-input
                style="width: 250px"
                v-model:value="form1.userAccount"
                placeholder="请输入账号"
              />
            </a-form-item>
            <a-form-item
              name="userPassword"
              label="密码"
              :rules="[
                { required: true, message: '请输入密码' },
                { min: 8, message: '密码不少于 8 位' },
                { max: 20, message: '密码不超过 20 位' },
                {
                  pattern: passwordPattern,
                  message: '密码必须包含大小写字母、数字和特殊符号',
                },
              ]"
            >
              <a-input-password
                style="width: 250px"
                v-model:value="form1.userPassword"
                placeholder="请输入密码"
              />
              <h3 @click="message.info('请联系管理员')">Forgot your password?</h3>
            </a-form-item>
            <a-form-item :wrapper-col="{ offset: 4, span: 20 }">
              <a-button type="primary" html-type="submit" class="inupbutton">登录</a-button>
            </a-form-item>
          </a-form>
        </div>
        <div class="overlaylong-Signup" v-if="disfiex == 1">
          <h2 class="overlaylongH2">Registered Account</h2>
          <a-form
            style="max-width: 700px; margin: 0 auto"
            label-align="left"
            :label-col="{ span: 7 }"
            :wrapper-col="{ span: 20 }"
            :model="form2"
            @finish="handleRegister"
          >
            <a-form-item
              name="userAccount"
              label="账号"
              :rules="[
                { required: true, message: '请输入账号' },
                { min: 4, message: '账号不少于 4 位' },
                { max: 20, message: '账号不超过 20 位' },
              ]"
            >
              <a-input
                style="width: 200px"
                v-model:value="form2.userAccount"
                placeholder="请输入账号"
              />
            </a-form-item>
            <a-form-item
              name="userPassword"
              label="密码"
              :rules="[
                { required: true, message: '请输入密码' },
                { min: 8, message: '密码不少于 8 位' },
                { max: 20, message: '密码不超过 20 位' },
                {
                  pattern: passwordPattern,
                  message: '密码必须包含大小写字母、数字和特殊符号',
                },
              ]"
            >
              <a-input-password
                style="width: 200px"
                v-model:value="form2.userPassword"
                placeholder="请输入密码"
              />
            </a-form-item>
            <a-form-item
              name="checkPassword"
              label="确认密码"
              :rules="[
                { required: true, message: '请再次输入密码' },
                { min: 8, message: '密码不少于 8 位' },
                { max: 20, message: '密码不超过 20 位' },
                {
                  pattern: passwordPattern,
                  message: '密码必须包含大小写字母、数字和特殊符号',
                },
              ]"
            >
              <a-input-password
                style="width: 200px"
                v-model:value="form2.checkPassword"
                placeholder="请输入确认密码"
              />
            </a-form-item>
            <a-form-item :wrapper-col="{ offset: 4, span: 20 }">
              <a-button type="primary" html-type="submit" class="inupbutton">注册</a-button>
            </a-form-item>
          </a-form>
        </div>
      </div>
      <div :class="overlaytitle">
        <div class="overlaytitle-Signin" v-if="disfiex == 0">
          <h2 class="overlaytitleH2">Hello,Friend!</h2>
          <p class="overlaytitleP">Enter your personal details and start journey with us</p>
          <div class="buttongohs" @click="Signin">Sign up</div>
        </div>
        <div class="overlaytitle-Signup" v-if="disfiex == 1">
          <h2 class="overlaytitleH2">Welcome Back!</h2>
          <p class="overlaytitleP">
            To keep connected with us please login with your personal info
          </p>
          <div class="buttongohs" @click="Signup">Sign in</div>
        </div>
      </div>
    </div>
  </div>
</template>
<script setup lang="ts">
import { reactive, ref } from 'vue'
import { useLoginUserStore } from '@/stores/user.ts'
import { useRouter } from 'vue-router'
import { userRegister, userLogin } from '@/api/userController'
import { message } from 'ant-design-vue'

const router = useRouter()
const loginUserStore = useLoginUserStore()
// Modified to require at least 3 out of 4 character types
const passwordPattern =
  /^((?=.*[a-z])(?=.*[A-Z])(?=.*\d)|(?=.*[a-z])(?=.*[A-Z])(?=.*[^A-Za-z0-9])|(?=.*[a-z])(?=.*\d)(?=.*[^A-Za-z0-9])|(?=.*[A-Z])(?=.*\d)(?=.*[^A-Za-z0-9])).*$/

const form1 = reactive<API.UserLoginRequest>({
  userAccount: '',
  userPassword: '',
})

const handleLogin = async () => {
  try {
    const res = await userLogin(form1)
    if (res.data.code === 0 && res.data.data) {
      await loginUserStore.fetchLoginUser()
      message.success('登录成功')
      router.push({
        path: '/',
        replace: true,
      })
    } else {
      message.error('登录失败: ' + (res.data.description || '未知错误'))
    }
  } catch (error) {
    message.error('网络错误，请稍后重试')
    console.error('Login error:', error)
  }
}

const form2 = reactive<API.UserRegisterRequest>({
  userAccount: '',
  userPassword: '',
  checkPassword: '',
})

const handleRegister = async () => {
  if (form2.checkPassword !== form2.userPassword) {
    message.error('二次输入的密码不一致')
    return
  }

  try {
    const res = await userRegister(form2)
    if (res.data.code === 0 && res.data.data) {
      message.success('注册成功')
      // Reset form after successful registration
      Object.assign(form2, {
        userAccount: '',
        userPassword: '',
        checkPassword: '',
      })
      disfiex.value = 0
    } else {
      message.error('注册失败: ' + (res.data.description || '未知错误'))
    }
  } catch (error) {
    message.error('网络错误，请稍后重试')
    console.error('Registration error:', error)
  }
}

const disfiex = ref(0)
const overlaylong = ref('overlaylong')
const overlaytitle = ref('overlaytitle')

const Signin = () => {
  overlaylong.value = 'overlaylongleft'
  overlaytitle.value = 'overlaytitleright'
  disfiex.value = 1
}

const Signup = () => {
  overlaylong.value = 'overlaylongright'
  overlaytitle.value = 'overlaytitleleft'
  disfiex.value = 0
}
</script>

<style scoped>
body,
html {
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100%;
  overflow: hidden;
}
.center {
  height: 88vh;
  background-image: url('https://gd-hbimg.huaban.com/9165dc3c0f8279ae5402d1f47212847bff68b49f3cb547-QEli8R');
  background-size: 100% 100%;
  background-repeat: no-repeat;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-direction: column;
}

h1 {
  font-size: 30px;
  color: black;
}

.logon {
  background-color: #fff;
  border-radius: 10px;
  box-shadow:
    0 14px 28px rgba(0, 0, 0, 0.25),
    0 10px 10px rgba(0, 0, 0, 0.22);
  /* position: relative;
  overflow: hidden; */
  width: 768px;
  max-width: 100%;
  min-height: 480px;
  margin-top: 20px;
  display: flex;
  background: -webkit-linear-gradient(right, #4284db, #29eac4);
}

.overlaylong {
  border-radius: 10px 0 0 10px;
  width: 50%;
  height: 100%;
  background-color: #fff;
  display: flex;
  align-items: center;
  justify-content: center;
}

.overlaylongleft {
  border-radius: 0px 10px 10px 0px;
  width: 50%;
  height: 100%;
  background-color: #fff;
  transform: translateX(100%);
  transition: transform 0.6s ease-in-out;
  display: flex;
  align-items: center;
  justify-content: center;
}

.overlaylongright {
  border-radius: 10px 0 0 10px;
  width: 50%;
  height: 100%;
  background-color: #fff;
  transform: translateX(0%);
  transition: transform 0.6s ease-in-out;
  display: flex;
  align-items: center;
  justify-content: center;
}

.overlaytitle {
  border-radius: 0px 10px 10px 0px;
  width: 50%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0);
  display: flex;
  align-items: center;
  justify-content: center;
}

.overlaytitleH2 {
  font-size: 30px;
  color: #fff;
  margin-top: 20px;
}

.overlaytitleP {
  font-size: 15px;
  color: #fff;
  margin-top: 20px;
}

.overlaytitleleft {
  border-radius: 0px 10px 10px 0px;
  width: 50%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0);
  display: flex;
  align-items: center;
  justify-content: center;
  transform: translateX(0%);
  transition: transform 0.6s ease-in-out;
}

.overlaytitleright {
  border-radius: 0px 10px 10px 0px;
  width: 50%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0);
  display: flex;
  align-items: center;
  justify-content: center;
  transform: translateX(-100%);
  transition: transform 0.6s ease-in-out;
}

.overlaytitle-Signin {
  display: flex;
  align-items: center;
  justify-content: center;
  flex-direction: column;
}

.overlaytitle-Signup {
  display: flex;
  align-items: center;
  justify-content: center;
  flex-direction: column;
}

.buttongohs {
  width: 180px;
  height: 40px;
  border-radius: 50px;
  border: 1px solid #fff;
  color: #fff;
  font-size: 15px;
  text-align: center;
  line-height: 40px;
  margin-top: 40px;
}

.overlaylongH2 {
  font-size: 25px;
  color: black;
  /* width: 250px; */
}

.overlaylong-Signin {
  display: flex;
  align-items: center;
  justify-content: center;
  flex-direction: column;
}

.overlaylong-Signup {
  display: flex;
  align-items: center;
  justify-content: center;
  flex-direction: column;
}

h3 {
  font-size: 10px;
  margin-top: 10px;
  cursor: pointer;
}
.inupbutton {
  background-color: #29eac4;
  border: none;
  width: 180px;
  height: 40px;
  border-radius: 50px;
  font-size: 15px;
  color: #fff;
  text-align: center;
  line-height: 30px;
  margin-top: 30px;
}
</style>

```

### 用户注销

一般鼠标悬浮在右上角用户头像时，会展示包含用户注销（退出登录）功能的下拉菜单。

```vue
<div v-if="loginUserStore.loginUser.id">
          <a-dropdown>
            <a-space>
              <a-avatar :src="loginUserStore.loginUser.userAvatar" />
              {{ loginUserStore.loginUser.userName ?? '无名' }}
            </a-space>
            <template #overlay>
              <a-menu>
                <a-menu-item @click="doLogout">
                  <LogoutOutlined />
                  退出登录
                </a-menu-item>
              </a-menu>
            </template>
          </a-dropdown>
        </div>
```

### 个人中心

#### 1. 新建路由

```ts
routes: [
    {
      path: '/',
      name: 'home',
      component: HomePage,
    },
    {
      path: '/user/login',
      name: '用户登录',
      component: UserLoginPage,
    },
    {
      path: '/user/center',
      name: '个人中心',
      component: UserProfilePage,
    },
    {
      path: '/admin/userManage',
      name: '用户管理',
      component: UserManagePage,
    },
  ],
```

#### 2. 页面跳转

```vue
                <a-menu-item @click="goUserCenter">
                  <UserOutlined />
                  个人中心
                </a-menu-item>
```

跳转函数

```ts
const goUserCenter = async () => {
  await router.push('/user/center')
}
```

### 用户管理

需求：允许管理员查看已注册的用户信息，能够根据用户名称搜索用户、并删除非法用户。
需要注意，要防止普通用户也能看到用户信息，所以要增加一定的权限控制，可以分为页面开发和权限控制两个步骤来实现。
编写页面：上方搜索栏，下方表格，表格需要支持分页。
我们可以拆分为几个步骤来开发：

#### 1. 表格

1. 利用Ant Design Vue的表格组件，找到需要的组件进行复制，先展示全部用户信息。

![image-20250729163531220](https://picbed-chengfu-1327906653.cos.ap-guangzhou.myqcloud.com/image/image-20250729163531220.webp)

2. 只需要根据自己的数据表，编写columns表格列，并传入获取到的data数据，组件就能自动帮我们展示出表格，非常方便。
   定义表格列：

```ts
const columns = [
  {
    title: 'id',
    dataIndex: 'id',
  },
  {
    title: '账号',
    dataIndex: 'userAccount',
  },
  {
    title: '用户名',
    dataIndex: 'userName',
  },
  {
    title: '头像',
    dataIndex: 'userAvatar',
  },
  {
    title: '简介',
    dataIndex: 'userProfile',
  },
  {
    title: '用户角色',
    dataIndex: 'userRole',
  },
  {
    title: '创建时间',
    dataIndex: 'createTime',
  },
  {
    title: '操作',
    key: 'action',
  },
]

```

3. 从后端获取数据

```ts
// 数据
const data = ref<API.UserVO[]>([])
const total = ref(0)

// 搜索条件
const searchParams = reactive<API.UserQueryRequest>({
  pageNum: 1,
  pageSize: 10,
})

// 获取数据
const fetchData = async () => {
  const res = await listUserVoByPage({
    ...searchParams,
  })
  if (res.data.data) {
    data.value = res.data.data.records ?? []
    total.value = res.data.data.totalRow ?? 0
  } else {
    message.error('获取数据失败，' + res.data.message)
  }
}

// 页面加载时请求一次
onMounted(() => {
  fetchData()
})

```

![image-20250729164021440](https://picbed-chengfu-1327906653.cos.ap-guangzhou.myqcloud.com/image/image-20250729164021440.webp)

查看页面，奇丑无比，接下来进行优化

4. 对于图片、用户角色、创建时间、更新时间之类的数据，我们可以有更好的展示方式

表格组件支持我们使用Vue的插槽自定义列的展示，参考Demo有样学样修改即可。

```vue
<template #bodyCell="{ column, record }">
  <template v-if="column.dataIndex === 'userAvatar'">
    <a-image :src="record.userAvatar" :width="120" />
  </template>
  <template v-else-if="column.dataIndex === 'userRole'">
    <div v-if="record.userRole === 'admin'">
      <a-tag color="green">管理员</a-tag>
    </div>
    <div v-else>
      <a-tag color="blue">普通用户</a-tag>
    </div>
  </template>
  <template v-else-if="column.dataIndex === 'createTime'">
    {{ dayjs(record.createTime).format('YYYY-MM-DD HH:mm:ss') }}
  </template>
  <template v-else-if="column.key === 'action'">
    <a-button danger>删除</a-button>
  </template>
</template>

```

![image-20250729164252173](https://picbed-chengfu-1327906653.cos.ap-guangzhou.myqcloud.com/image/image-20250729164252173.webp)

#### 2.分页

1. 表格组件支持分页，首先编写一个分页变量，指定当前页号、页面大小、数据总数、展示总数的文案等参数：

```ts
// 分页参数
const pagination = computed(() => {
  return {
    current: searchParams.pageNum ?? 1,
    pageSize: searchParams.pageSize ?? 10,
    total: total.value,
    showSizeChanger: true,
    showTotal: (total: number) => `共 ${total} 条`,
  }
})
```

2. 编写doTableChange函数，当用户切换页号和页面大小时，需要更新searchParams搜索条件的值，并触发搜索：

```ts
// 表格变化处理
const doTableChange = (page: any) => {
  searchParams.pageNum = page.current
  searchParams.pageSize = page.pageSize
  fetchData()
}
```

3. 给表格组件绑定分页参数和表格切换事件：

```ts
<a-table
  :columns="columns"
  :data-source="data"
  :pagination="pagination"
  @change="doTableChange"
>
```

![image-20250729164642274](https://picbed-chengfu-1327906653.cos.ap-guangzhou.myqcloud.com/image/image-20250729164642274.webp)

#### 3.搜索

利用Ant Design Vue的搜索组件，实现对数据的搜索。

1. 其实搜索本质上就是让用户填写搜索条件表单，此处我们需要根据账号和用户呢称搜索，编写表单代码：

```vue
```

使用searchParams接受用户的输入，相当于所有的搜索条件全部存到了searchParams中，便于统一维护

2. 点击搜索按钮时会触发表单提交，表单提交时需要将页号重置为1，并获取数据。编写对应的函数：

#### 4. 删除

比如开发删除功能，先编写点击删除按钮后的处理函数：

```ts
// 删除数据
const doDelete = async (id: string) => {
  if (!id) {
    return
  }
  const res = await deleteUser({ id })
  if (res.data.code === 0) {
    message.success('删除成功')
    // 刷新数据
    fetchData()
  } else {
    message.error('删除失败')
  }
}

```

然后绘删除按钮邦定事件：

```ts
<a-button danger @click="doDelete(record.id)">删除</a-button>
```

### 用户权限控制

虽然后端获取用户列表的接口做了权限校验，防止非管理员用户获取到。但一般情况下，为了保证系统安全和提升用户体验，前端也需要对权限进行控制。
有2种实现方式：单页面控制权限，或者全局控制权限。

思路都是一致的，在进入某个页面时判断用户是否具有该页面的权限，无非是把权限校验相关的代码写在单个页面内，只是写到一个独立的文件中罢了。
*建议编写独立的全局权限控制文件。*可以利用Vue Router的路由守卫实现，每次切换并进入页面前，都会检查一下前用户是否具有特定页面的权限。
在src下编写access..ts权限校验文件，可以自己定义逻辑，比如用页面前缀来统一判断：

```ts
import { useLoginUserStore } from '@/stores/user.ts'
import { message } from 'ant-design-vue'
import router from '@/router'

// 是否为首次获取登录用户
let firstFetchLoginUser = true

/**
 * 全局权限校验
 */
router.beforeEach(async (to, from, next) => {
  const loginUserStore = useLoginUserStore()
  let loginUser = loginUserStore.loginUser
  // 确保页面刷新，首次加载时，能够等后端返回用户信息后再校验权限
  if (firstFetchLoginUser) {
    await loginUserStore.fetchLoginUser()
    loginUser = loginUserStore.loginUser
    firstFetchLoginUser = false
  }
  const toUrl = to.fullPath
  if (toUrl.startsWith('/admin')) {
    if (!loginUser || loginUser.userRole !== 'admin') {
      message.error('没有权限')
      next(`/user/login?redirect=${to.fullPath}`)
      return
    }
  }
  next()
})
```

注意，上述代码中，我们为了确保页面刷新时，从后端拿到用户信息后再进行权限校验，使用awit等待后端接口返回，并重新赋值给loginUser。同时，为了防止每次切换路由都从远程获取用户信息，定义了firstFetchLoginUser变量，用于控制在刷新页面后只会请求后端一次。
由于在access.ts中已经获取到了登录用户信息，可以移除掉之前在App.vue中获取登录用户信息的逻辑，避免重复请求。

```ts
import '@/access'
```

虽然已经满足了需求，但是如果用户不是管理员，其实不应该看到"用户管理”菜单。因此我们还要修改GlobalHeader菜单项配置，根据权限决定是否展示某些菜单项。
编写一个过滤菜单项的函数：

```ts
// 菜单配置项
const originItems = [
  {
    key: '/',
    icon: () => h(HomeOutlined),
    label: '主页',
    title: '主页',
  },
  {
    key: '/admin/userManage',
    label: '用户管理',
    title: '用户管理',
  },
  {
    key: 'others',
    label: h('a', { href: 'https://www.codefather.cn', target: '_blank' }, '编程导航'),
    title: '编程导航',
  },
]

// 过滤菜单项
const filterMenus = (menus = [] as MenuProps['items']) => {
  return menus?.filter((menu) => {
    const menuKey = menu?.key as string
    if (menuKey?.startsWith('/admin')) {
      const loginUser = loginUserStore.loginUser
      if (!loginUser || loginUser.userRole !== 'admin') {
        return false
      }
    }
    return true
  })
}

// 展示在菜单的路由数组
const menuItems = computed<MenuProps['items']>(() => filterMenus(originItems))

```

